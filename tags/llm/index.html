<!doctype html>
<html lang="ko" dir="ltr" class="blog-wrapper blog-tags-post-list-page plugin-blog plugin-id-default" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.5.2">
<title data-rh="true">&quot;llm&quot; 태그로 연결된 1개 게시물개의 게시물이 있습니다. | The Sapzil</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://blog.sapzil.org/tags/llm/"><meta data-rh="true" property="og:locale" content="ko"><meta data-rh="true" name="docusaurus_locale" content="ko"><meta data-rh="true" name="docsearch:language" content="ko"><meta data-rh="true" property="og:title" content="&quot;llm&quot; 태그로 연결된 1개 게시물개의 게시물이 있습니다. | The Sapzil"><meta data-rh="true" name="docusaurus_tag" content="blog_tags_posts"><meta data-rh="true" name="docsearch:docusaurus_tag" content="blog_tags_posts"><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://blog.sapzil.org/tags/llm/"><link data-rh="true" rel="alternate" href="https://blog.sapzil.org/tags/llm/" hreflang="ko"><link data-rh="true" rel="alternate" href="https://blog.sapzil.org/tags/llm/" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/rss.xml" title="The Sapzil RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/atom.xml" title="The Sapzil Atom Feed">

<link rel="preconnect" href="https://www.google-analytics.com">
<link rel="preconnect" href="https://www.googletagmanager.com">
<script async src="https://www.googletagmanager.com/gtag/js?id=G-KFBZE189TB"></script>
<script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-KFBZE189TB",{})</script>


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.24/dist/katex.min.css" integrity="sha384-odtC+0UGzzFL/6PNoE8rX/SPcQDXBJ+uRepguP4QkPCm2LBxH3FA3y+fKSiJ+AmM" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/styles.94625bf3.css">
<script src="/assets/js/runtime~main.803b36b6.js" defer="defer"></script>
<script src="/assets/js/main.e1784ed8.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const n=new URLSearchParams(window.location.search).entries();for(var[t,e]of n)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="본문으로 건너뛰기"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">본문으로 건너뛰기</a></div><nav aria-label="메인" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="사이드바 펼치거나 접기" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><b class="navbar__title text--truncate">👷 The Sapzil</b></a><a class="navbar__item navbar__link" href="/">Posts</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/tags/">Tags</a></div><div class="navbar__items navbar__items--right"><div class="navbarSearchContainer_Bca1"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_re4s thin-scrollbar" aria-label="최근 블로그 문서 둘러보기"><div class="sidebarItemTitle_pO2u margin-bottom--md">Recent posts</div><div role="group"><h3 class="yearGroupHeading_rMGB">2025</h3><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/2025/05/28/streaming-structured-outputs/">Streaming Structured Outputs</a></li></ul></div><div role="group"><h3 class="yearGroupHeading_rMGB">2023</h3><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/2023/01/22/k3s/">나의 k3s 구성 둘러보기</a></li></ul></div><div role="group"><h3 class="yearGroupHeading_rMGB">2022</h3><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/2022/03/04/gradle-convention-plugins/">Gradle Convention Plugins 삽질기</a></li></ul></div><div role="group"><h3 class="yearGroupHeading_rMGB">2021</h3><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/2021/05/09/nix/">‘순수 함수형’ 패키지 관리자 Nix 맛보기</a></li></ul></div><div role="group"><h3 class="yearGroupHeading_rMGB">2019</h3><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/2019/12/29/microservices-1/">나도 MSA 한번 해보자 (1)</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/2019/06/09/docker-desktop-for-windows-home/">Windows 10 Home에 Docker Desktop 설치하기</a></li></ul></div><div role="group"><h3 class="yearGroupHeading_rMGB">2018</h3><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/2018/08/26/kotlin-jpa-pitfalls-embeddable/">Kotlin에서 JPA 사용할 때 주의할 점 (2) - Embeddable, IdClass</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/2018/06/20/gradle-subproject-grouping/">Gradle에서 서브 프로젝트를 한 디렉토리에 몰아넣기</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/2018/01/21/taming-maven-transitive-dependencies/">Maven의 Transitive Dependency 길들이기</a></li></ul></div><div role="group"><h3 class="yearGroupHeading_rMGB">2017</h3><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/2017/11/02/kotlin-jpa-pitfalls/">Kotlin에서 JPA 사용할 때 주의할 점</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/2017/07/16/redux-observable/">redux-observable 사용하기</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/2017/07/10/diffmonster/">Diff Monster를 소개합니다</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/2017/04/01/do-not-trust-sql-transaction/">SQL 트랜잭션 - 믿는 도끼에 발등 찍힌다</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/2017/03/12/testing-restful-api-servers/">RESTful API 서버 테스트하기</a></li></ul></div><div role="group"><h3 class="yearGroupHeading_rMGB">2016</h3><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/2016/12/15/react-with-rx/">RxJS로 React 컴포넌트 상태 관리하기</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/2016/08/04/jersey-hk2/">Jersey 2.x에 내장된 의존성 주입 기능 사용하기</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/2016/07/29/animeta-react-ssr/">애니메타의 React 서버 렌더링 아키텍쳐</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/2016/03/20/react-internals-utils/">React 소스 코드 읽기 - 유틸리티들</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/2016/03/17/react-internals-elements/">React 소스 코드 읽기 - ReactElement</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/2016/03/09/react-internals-modules/">React 소스 코드 읽기 - 모듈 시스템</a></li></ul></div><div role="group"><h3 class="yearGroupHeading_rMGB">2015</h3><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/2015/10/24/advanced-uwsgi/">uWSGI의 고급 기능들</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/2015/10/07/thinking-in-graphql/">Thinking in GraphQL (번역)</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/2015/09/01/graphql-rfc/">GraphQL 살펴보기</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/2015/05/15/graphql-and-relay/">GraphQL과 Relay: 웹 애플리케이션 개발의 미래</a></li></ul></div><div role="group"><h3 class="yearGroupHeading_rMGB">2014</h3><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/2014/09/21/python-web-app-deploy/">파이썬 웹 애플리케이션 배포: 고려할 점들</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/2014/08/12/upstart/">Upstart로 오래 도는 프로세스 관리하기</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/2014/08/10/jquery-to-react/">jQuery to React</a></li></ul></div></nav></aside><main class="col col--7"><header class="margin-bottom--xl"><h1>&quot;llm&quot; 태그로 연결된 1개 게시물개의 게시물이 있습니다.</h1><a href="/tags/">모든 태그 보기</a></header><article class="margin-bottom--xl"><header><h2 class="title_f1Hy"><a href="/2025/05/28/streaming-structured-outputs/">Streaming Structured Outputs</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2025-05-28T00:00:00.000Z">2025년 5월 28일</time> · <!-- -->약 13분</div></header><div class="markdown"><h2 class="anchor anchorWithStickyNavbar_LWe7" id="구조화된-출력-structured-output">구조화된 출력 (Structured Output)<a href="#구조화된-출력-structured-output" class="hash-link" aria-label="구조화된 출력 (Structured Output)에 대한 직접 링크" title="구조화된 출력 (Structured Output)에 대한 직접 링크">​</a></h2>
<p>LLM은 일반적으로 대화형 인터페이스에서 자연어 텍스트를 생성하는 데 사용되지만, AI 애플리케이션에서는 구조화된 데이터 출력이 필요한 경우가 많습니다.</p>
<p>이를 위해 LLM 제공 업체들은 특정 스키마를 준수하는 JSON 형식의 출력을 강제하는 구조화된 출력(structured output) 기능을 제공합니다. (예: <a href="https://platform.openai.com/docs/guides/structured-outputs?api-mode=chat" target="_blank" rel="noopener noreferrer">OpenAI</a>, <a href="https://ai.google.dev/gemini-api/docs/structured-output" target="_blank" rel="noopener noreferrer">Google</a>)</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="구조화된-출력의-스트리밍">구조화된 출력의 스트리밍<a href="#구조화된-출력의-스트리밍" class="hash-link" aria-label="구조화된 출력의 스트리밍에 대한 직접 링크" title="구조화된 출력의 스트리밍에 대한 직접 링크">​</a></h2>
<p>복잡하거나 큰 JSON 구조를 생성해야 하는 경우, 전체 응답이 완료될 때까지 기다려야 하므로 사용자 경험이 저하될 수 있습니다. 이때 필요한 것이 바로 스트리밍입니다.</p>
<p>LLM 스트리밍은 응답을 토큰 단위로 생성하면서 실시간으로 부분적인 결과를 전송하는 방식입니다. 전체 JSON이 완성될 때까지 기다리는 대신, 생성되는 부분부터 순차적으로 클라이언트에 전달합니다.</p>
<p>예를 들어, <code>{&quot;userId&quot;: &quot;12345&quot;}</code>가 최종적인 전체 응답이라면, 다음과 같이 토큰 단위로 응답이 스트리밍될 수 있습니다:</p>
<ol>
<li><code>{</code></li>
<li><code>&quot;</code></li>
<li><code>user</code></li>
<li><code>Id</code></li>
<li><code>&quot;:</code></li>
<li>...</li>
</ol>
<p>하지만 마지막 토큰을 받기 전까지는 완전한 JSON 형태가 아니므로 일반적인 JSON 파서를 활용할 수 없습니다. 이 문제를 어떻게 해결해야 할까요?</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="부분-파싱-partial-parsing">부분 파싱 (Partial Parsing)<a href="#부분-파싱-partial-parsing" class="hash-link" aria-label="부분 파싱 (Partial Parsing)에 대한 직접 링크" title="부분 파싱 (Partial Parsing)에 대한 직접 링크">​</a></h3>
<p>기존에도 JSON을 스트리밍 방식으로 파싱할 수 있는 라이브러리가 존재하지만, 일반적으로는 파싱 관점에서의 토큰(LLM 토큰과는 다름)이 완성된 후에야 사용자에게 정보가 전달됩니다.</p>
<p>예를 들어, JSON이 <code>{&quot;sentence&quot;: &quot;Hello,</code>처  럼 따옴표가 닫히지 않은 상태라면, 닫는 따옴표를 만날 때까지 기다려야 비로소 <code>sentence</code>의 값을 얻을 수 있습니다. 구조화된 응답이라도 긴 문자열을 포함할 수 있기 때문에, 기존의 스트리밍 파서로는 원하는 수준의 응답성을 구현하기 어려울 수 있습니다.</p>
<p>이러한 문제를 해결하기 위해, 스트리밍 도중의 불완전한 JSON을 파싱할 수 있는 라이브러리들이 있습니다:</p>
<ul>
<li>Python: <a href="https://github.com/mangiucugna/json_repair" target="_blank" rel="noopener noreferrer">json_repair</a></li>
<li>JavaScript: <a href="https://github.com/st3w4r/openai-partial-stream" target="_blank" rel="noopener noreferrer">openai-partial-stream</a></li>
<li>(이 외에도 다양한 라이브러리가 존재합니다.)</li>
</ul>
<p>위에서 예시로 든 <code>{&quot;sentence&quot;: &quot;Hello,</code>를 부분 파싱하면, <code>{&quot;sentence&quot;: &quot;Hello,&quot;}</code>처럼 현재까지 파악된 정보를 바탕으로 완성된 형태의 객체를 추출할 수 있습니다.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="부분-파싱-희망-사항">부분 파싱: 희망 사항<a href="#부분-파싱-희망-사항" class="hash-link" aria-label="부분 파싱: 희망 사항에 대한 직접 링크" title="부분 파싱: 희망 사항에 대한 직접 링크">​</a></h3>
<p>LLM에 넘길 JSON 스키마를 정의할 때 Pydantic이나 Zod 같은 라이브러리를 사용하게 되는데요. <strong>완성된 타입 정의로부터 부분 파싱된 객체의 타입 정의를 도출</strong>할 수 있다면 편리할 것 같습니다.
(특히 Pydantic은 런타임에 스키마 정의하는 것은 가능하지만 mypy와 같은 정적 타입 검사 도구에서 부분 파싱된 객체의 타입을 추론할 수 있는 방법이 없는 것 같습니다.)</p>
<p>또한 <strong>객체의 어떤 부분이 부분 파싱된 상태인지 알 수 있는 파서</strong>가 있다  면, 필드에 따라 부분 파싱된 경우의 표현 방식을 다르게 할 수 있어 유용할 것 같습니다.</p>
<p>예를 들어, <code>{&quot;title&quot;: &quot;Hello, world!&quot;, &quot;tags&quot;: [&quot;python&quot;, &quot;llm&quot;]}</code>과 같은 JSON에서 <code>title</code>은 완성되지 않은 상황에서도 노출하고, <code>tags</code>는 완성된 항목만 노출하기를 원할 수 있습니다.</p>
<p>즉 <code>&quot;tags&quot;: [&quot;python&quot;, &quot;ll</code>까지 들어왔을 때는 두번째 태그는 아직 미완성인 상태이므로 <code>python</code>만 노출하는 것입니다. 그런 경우에 파싱 결과를 다음과 같이 얻을 수 있으면 원하는 기능을 구현할 수 있을 것 같습니다.</p>
<div class="language-json codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-json codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token property" style="color:#36acaa">&quot;title&quot;</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&quot;Hello, world!&quot;</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token property" style="color:#36acaa">&quot;tags&quot;</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">[</span><span class="token string" style="color:#e3116c">&quot;python&quot;</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&quot;ll&quot;</span><span class="token punctuation" style="color:#393A34">]</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token property" style="color:#36acaa">&quot;$partial&quot;</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token property" style="color:#36acaa">&quot;tags&quot;</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token boolean" style="color:#36acaa">true</span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="클립보드에 코드 복사" title="복사" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>위와 같은 기능을 제공하는 라이브러리를 아직 찾지 못했는데, 만약 없다면 오픈소스 프로젝트로 만들어보기 좋을 것 같습니다.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="구조화된-출력-스트리밍과-api-설계">구조화된 출력 스트리밍과 API 설계<a href="#구조화된-출력-스트리밍과-api-설계" class="hash-link" aria-label="구조화된 출력 스트리밍과 API 설계에 대한 직접 링크" title="구조화된 출력 스트리밍과 API 설계에 대한 직접 링크">​</a></h2>
<p>실제 애플리케이션을 구현할 때, 프론트엔드에서 LLM 제공자를 직접 호출하기보다는 요금 부과나 사용량 제한 등을 관리하기 위해 백엔드 서버를 경유하는 것이 일반적입니다. 이 경우, 구조화된 출력을 스트리밍한다면 API를 어떻게 설계하는 것이 좋을까요?</p>
<p>가장 단순한 방법은 백엔드가 LLM이 출력하는 JSON 문자열 조각을 그대로 프론트엔드에 전달하고, 프론트엔드에서 부분 파싱을 수행하는 것입니다. 하지만 여기에는 몇 가지 문제가 있습니다:</p>
<ul>
<li><strong>구현 세부 정보 노출</strong>: LLM의 스키마가 프론트엔드까지 노출되어 불필요한 결합이 발생합니다. 더 나은 생성 결과를 위해 스키마를 변경하면 프론트엔드 코드까지 수정해야 할 수 있습니다.</li>
<li><strong>호환성 문제</strong>: 새로운 기능을 구현하기 위해 LLM 스키마를 변경할 때, 이전 버전의 프론트엔드와 동시에 호환되도록 만들기가 어려울 수 있습니다.</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="호환성-문제의-예시">호환성 문제의 예시<a href="#호환성-문제의-예시" class="hash-link" aria-label="호환성 문제의 예시에 대한 직접 링크" title="호환성 문제의 예시에 대한 직접 링크">​</a></h3>
<p>장소 리뷰를 요약하는 서비스를 예로 들어보겠습니다.</p>
<p>원래 다음과 같은 내용을 생성하고 있었다고 가정합니다 (v1):</p>
<div class="language-js codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-js codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token punctuation" style="color:#393A34">{</span><span class="token plain">  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token string-property property" style="color:#36acaa">&quot;summary&quot;</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token string" style="color:#e3116c">&quot;음식이 맛있어요&quot;</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token string" style="color:#e3116c">&quot;인테리어가 멋져요&quot;</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token string" style="color:#e3116c">&quot;재료가 신선해요&quot;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token punctuation" style="color:#393A34">]</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="클립보드에 코드 복사" title="복사" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>각 요약 항목에 이모지를 추가하는 요구사항이 새로 생겼다고 가정해봅시다 (v2):</p>
<div class="language-js codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-js codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token punctuation" style="color:#393A34">{</span><span class="token plain">  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token string-property property" style="color:#36acaa">&quot;summaryV2&quot;</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token punctuation" style="color:#393A34">{</span><span class="token string-property property" style="color:#36acaa">&quot;emoji&quot;</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&quot;🍽️&quot;</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token string-property property" style="color:#36acaa">&quot;text&quot;</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&quot;음식이 맛있어요&quot;</span><span class="token punctuation" style="color:#393A34">}</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token punctuation" style="color:#393A34">{</span><span class="token string-property property" style="color:#36acaa">&quot;emoji&quot;</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&quot;🏠&quot;</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token string-property property" style="color:#36acaa">&quot;text&quot;</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&quot;인테리어가 멋져요&quot;</span><span class="token punctuation" style="color:#393A34">}</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token punctuation" style="color:#393A34">{</span><span class="token string-property property" style="color:#36acaa">&quot;emoji&quot;</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&quot;🥗&quot;</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token string-property property" style="color:#36acaa">&quot;text&quot;</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&quot;재료가 신선해요&quot;</span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token punctuation" style="color:#393A34">]</span><span class="token plain">  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="클립보드에 코드 복사" title="복사" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>위 v2 응답이 v1 프론트엔드와도 호환되려면 다음과 같은 형식이 되어야 합니다:</p>
<div class="language-js codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-js codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token punctuation" style="color:#393A34">{</span><span class="token plain">  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token string-property property" style="color:#36acaa">&quot;summaryV2&quot;</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token punctuation" style="color:#393A34">{</span><span class="token string-property property" style="color:#36acaa">&quot;emoji&quot;</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&quot;🍽️&quot;</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token string-property property" style="color:#36acaa">&quot;text&quot;</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&quot;음식이 맛있어요&quot;</span><span class="token punctuation" style="color:#393A34">}</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token punctuation" style="color:#393A34">{</span><span class="token string-property property" style="color:#36acaa">&quot;emoji&quot;</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&quot;🏠&quot;</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token string-property property" style="color:#36acaa">&quot;text&quot;</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&quot;인테리어가 멋져요&quot;</span><span class="token punctuation" style="color:#393A34">}</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token punctuation" style="color:#393A34">{</span><span class="token string-property property" style="color:#36acaa">&quot;emoji&quot;</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&quot;🥗&quot;</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token string-property property" style="color:#36acaa">&quot;text&quot;</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&quot;재료가 신선해요&quot;</span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token punctuation" style="color:#393A34">]</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token string-property property" style="color:#36acaa">&quot;summary&quot;</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token string" style="color:#e3116c">&quot;음식이 맛있어요&quot;</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain">  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token string" style="color:#e3116c">&quot;인테리어가 멋져요&quot;</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain">  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token string" style="color:#e3116c">&quot;재료가 신선해요&quot;</span><span class="token plain">  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token punctuation" style="color:#393A34">]</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="클립보드에 코드 복사" title="복사" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>이때 LLM에 v1과 v2 호환 형식에 맞게 생성을 요청하면 몇 가지 문제가 발생할 수 있습니다:</p>
<ul>
<li>응답이 앞에서부터 순차적으로 생성되므로, v1 프론트엔드는 <code>summaryV2</code> 필드가 생성되는 동안 아무런 결과를 출력할 수 없습니다.</li>
<li><code>summaryV2</code>와 <code>summary</code>의 텍스트 내용이 일치한다고 보장할 수 없습니다.</li>
<li>중복된 내용을 생성하므로 LLM 출력 비용이 추가로 발생합니다.</li>
</ul>
<p>클라이언트 버전을 확인하여 응답 생성 버전을 분기하는 방법으로 해결할 수 있지만, 여전히 구현 세부 정보 노출 문제는 남아있습니다.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="객체-동기화-방식">객체 동기화 방식<a href="#객체-동기화-방식" class="hash-link" aria-label="객체 동기화 방식에 대한 직접 링크" title="객체 동기화 방식에 대한 직접 링크">​</a></h3>
<p>v2 응답 스트림에서 파생되는 v1 호환용 필드까지 함께 클라이언트에 실시  간으로 전달하는 것은, 단순 선형 스트리밍 방식으로는 구현하기 어렵습니다. 따라서 JSON 조각을 선형적으로 스트리밍하는 대신, 백엔드와 프론트엔드 간에 JSON 객체를 동기화하는 방식으로 접근 방식을 바꿔볼 수 있습니다.</p>
<p>이렇게 하면 백엔드에서 프론트엔드에 전달하는 객체의 형식이 훨씬 자유로워지고, LLM의 출력 스키마와도 결합을 줄일 수 있습니다. 하위호환 문제도 프론트엔드에 전달하기 직전에 변환 단계를 추가해서 v1 하위 호환 필드를 채워주면 호환성 문제를 해결할 수 있습니다.</p>
<p>객체 동기화의 구체적인 방법으로, 간단하게는 백엔드에서 부분 파싱된 객체 전체를 매번 프론트엔드에 전달할 수 있습니다. 그러나 전체 객체를 매번 전송하는 방식은 데이터 중복으로 인해 통신이 비효율적이 됩니다. 더 효율적인 통신을 위해서는 변경 사항만을 전달할 필요가 있습니다. 이를 위해 <a href="https://datatracker.ietf.org/doc/html/rfc6902" target="_blank" rel="noopener noreferrer">JSON Patch (RFC 6902)</a>와 같은 표준을 활용해볼 수 있습니다.</p>
<p>아쉽게도 JSON Patch의 한계점 중 하나는, LLM이 생성하는 긴 텍스트처럼 점진적으로 내용이 추가되는 문자열을 표현하기 위한 &#x27;덧붙이기(append)&#x27; 연산이 표준에 직접적으로 정의되어 있지 않다는 것입니다. 따라서 매우 긴 문자열 필드를 스트리밍할 때는 (비효율적으로) 항상 문자열 전체를 교체해야 합니다. 필요하다면 별도로 append 연산을 정의해볼 수 있겠습니다.</p>
<p>참고로 ChatGPT도 JSON 객체의 변경사항만을 스트리밍하는 방식을 사용하는 것을 확인할 수 있습니다.</p>
<p><img decoding="async" loading="lazy" alt="ChatGPT delta encoding" src="/assets/images/chatgpt-delta-c27015763269dec96b7bd42da8f3872e.png" width="1272" height="266" class="img_ev3q"></p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="결론">결론<a href="#결론" class="hash-link" aria-label="결론에 대한 직접 링크" title="결론에 대한 직접 링크">​</a></h2>
<ul>
<li>LLM에서 구조화된 JSON 출력을 스트리밍할 때, 부분 파싱을 통해 실시간으로 결과를 처리할 수 있습니다.</li>
<li>JSON 조각을 단순히 스트리밍하는 것보다는, 객체 동기화 방식이 프론트엔드와의 결합을 줄이고 하위 호환성을 유지할 수 있다고 생각합니다.</li>
</ul></div><footer class="row docusaurus-mt-lg"><div class="col"><b>태그:</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/tags/llm/">llm</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/tags/streaming/">streaming</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/tags/json/">json</a></li></ul></div></footer></article><nav class="pagination-nav" aria-label="블로그 게시물 목록 탐색"></nav></main></div></div></div><footer class="footer"><div class="container container-fluid"><div class="footer__bottom text--center"><div class="footer__copyright">© 2025. All rights reserved.</div></div></div></footer></div>
</body>
</html>